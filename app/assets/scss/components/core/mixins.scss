/*
* pushes the target to its own render layer on the gpu
*
*/
 @mixin layer() {
    -webkit-backface-visibility: hidden;
        -moz-backface-visibility: hidden;
            backface-visibility: hidden;
}

/*
* pushes the target to its own render layer on the gpu
*
*/
@mixin gpu() {
    transform: translateZ(0);
    backface-visibility: hidden;
    transform-style: preserve-3d;
}

@mixin gpu-reset() {
    transform: none;
    perspective: none;
    backface-visibility: hidden;
}



/*
  * Outputs properties that use rem with a px fallback.
  * It also takes px values and converts them to rem.
  *
  * @param property
  * @param values
  * @param default-font-size int optional
  * @returns
  *   <property>: <parsed value>px;
  *   <property>: <parsed value>rem;
  *
  * @example
  *   .selector {
  *     @include rem(font-size, 1.3);
  *     @include rem(padding, 20px);
  *   }
  */
@mixin rem ($property, $values, $main-font-size: 16px) {

  // Empty list for all values in px
  $px-values: ();
  $rem-values: ();

  // Iterate over entries
  @each $value in $values {

    // If the value is zero or of a type that doesnâ€™t need conversion, return the value untouched
    @if ( $value == 0 ) or type_of($value) == string or type_of($value) == color or type_of($value) == bool {
      $px-values: append($px-values, $value);
      $rem-values: append($rem-values, $value);

    // Otherwise convert it properly
    } @else {
      $unit: unit($value);

      @if $unit == 'px' {
        $px-values: append($px-values, #{parseInt($value)}px );
        $rem-values: append($rem-values, (parseInt($value) / parseInt($main-font-size) * 1rem));
      } @else {
        $px-values: append($px-values, ($value * $main-font-size) );
        $rem-values: append($rem-values, #{$value}rem);
      }

    }
  }

  // Return the property and its list of converted values
  #{$property}: #{$px-values};
  #{$property}: #{$rem-values};
}


// @font-face mixin
// Order of the includes matters, and it is: normal, bold, italic, bold+italic.
// Forked from Bourbon. https://github.com/thoughtbot/bourbon/
@mixin font-face($font-family, $file-path, $weight: normal, $style: normal) {
  @font-face {
    font-family: $font-family;
    font-weight: $weight;
    font-style: $style;

    src: url('#{$file-path}.eot');
    src: url('#{$file-path}.eot?#iefix') format('embedded-opentype'),
         url('#{$file-path}.woff') format('woff'),
         url('#{$file-path}.ttf') format('truetype'),
         url('#{$file-path}.svg##{$font-family}') format('svg');
  }
}


// Mixin for cross browser inline-block
// http://blog.mozilla.org/webdev/2009/02/20/cross-browser-inline-block/
// ------------------
@mixin inline-block {
  display: -moz-inline-stack;
  -moz-box-orient: vertical;
  display: inline-block;
  *display: inline;
  vertical-align: top;
  *zoom: 1;
}


// Clearfix
@mixin cf() {
  *zoom: 1;
  &:before, &:after {
    content: '';
    display: table;
  }
  &:after {
    clear: both;
  }
}



// Horizontal/Vertical/Both Alignment - Parent container needs position relative. IE9+
@mixin align($direction:both) {
    position: absolute;
    transform-style: preserve-3d;
    @if ($direction==horizontal) or ($direction==h) {
        left: 50%;
        transform: translateX(-50%);
    }
    @else if ($direction==vertical) or ($direction==v) {
        top: 50%;
        transform: translateY(-50%);
    }
    @else {
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
    }
}



@mixin line-clamp($numLines:1, $lineHeight:1.412) {
    overflow: hidden;
    text-overflow: -o-ellipsis-lastline;
    text-overflow: ellipsis;
    display: block;
    display: -webkit-box;
    box-orient: vertical;
    -webkit-box-orient: vertical;
    -webkit-line-clamp: $numLines;
    max-height: ($numLines * $lineHeight)+unquote("em");
}
