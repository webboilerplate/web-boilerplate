//pushes the target to its own render layer on the gpu
//
 @mixin layer() {
    -webkit-backface-visibility: hidden;
        -moz-backface-visibility: hidden;
            backface-visibility: hidden;
}

@mixin layer-reset() {
    -webkit-backface-visibility: initial;
        -moz-backface-visibility: initial;
            backface-visibility: initial;
}

// pushes the target to its own render layer on the gpu
//
@mixin gpu() {
    transform: translateZ(0);
    backface-visibility: hidden;
    transform-style: preserve-3d;
}

@mixin gpu-reset() {
    transform: none;
    perspective: none;
    backface-visibility: initial;
}


// breakpoint
// example @include breakpoint(940) { width:80%; }
//
@mixin bp($size, $mobile-first : false) {
  @if ($mobile-first == true ){
    @media only screen and (min-width: $size + px) { @content; }
  }
  @else{
    @media only screen and (max-width: $size + px) { @content; }
  }
}


// size
//
@mixin size($width, $height: $width) {
  width: $width;
  height: $height;
}


// placeholder
//
@mixin placeholder($color: $text-color, $alpha: .8) {
  &::-webkit-input-placeholder {
    color: rgba($color, $alpha);
  }  /* WebKit browsers */

  &:-moz-placeholder {
    color: rgba($color, 1)
  }  /* Mozilla Firefox 4 to 18 */

  &::-moz-placeholder {
    color: rgba($color, 1)
  }  /* Mozilla Firefox 19+ */

  &:-ms-input-placeholder {
    color: rgba($color, $alpha)
  } /* Internet Explorer 10+ */
}



// Text ellipsis
// Requires inline-block or block for proper styling

@mixin text-ellipsis() {
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}



//
// Outputs properties that use rem with a px fallback.
// It also takes px values and converts them to rem.
//
// @param property
// @param values
// @param default-font-size int optional
// @returns
//   <property>: <parsed value>px;
//   <property>: <parsed value>rem;
//
// @example
//   .selector {
//     @include rem(font-size, 1.3);
//     @include rem(padding, 20px);
//   }
//
@mixin rem ($property, $values, $main-font-size: 16px) {

  // Empty list for all values in px
  $px-values: ();
  $rem-values: ();

  // Iterate over entries
  @each $value in $values {

    // If the value is zero or of a type that doesnâ€™t need conversion, return the value untouched
    @if ( $value == 0 ) or type_of($value) == string or type_of($value) == color or type_of($value) == bool {
      $px-values: append($px-values, $value);
      $rem-values: append($rem-values, $value);

    // Otherwise convert it properly
    } @else {
      $unit: unit($value);

      @if $unit == 'px' {
        $px-values: append($px-values, #{parseInt($value)}px );
        $rem-values: append($rem-values, (parseInt($value) / parseInt($main-font-size) * 1rem));
      } @else {
        $px-values: append($px-values, ($value * $main-font-size) );
        $rem-values: append($rem-values, #{$value}rem);
      }

    }
  }

  // Return the property and its list of converted values
  #{$property}: #{$px-values};
  #{$property}: #{$rem-values};
}


// @font-face mixin
// Order of the includes matters, and it is: normal, bold, italic, bold+italic.
// Forked from Bourbon. https://github.com/thoughtbot/bourbon/
@mixin font-face($font-family, $file-path, $weight: normal, $style: normal) {
  @font-face {
    font-family: $font-family;
    font-weight: $weight;
    font-style: $style;

    src: url('#{$file-path}.eot');
    src: url('#{$file-path}.eot?#iefix') format('embedded-opentype'),
         url('#{$file-path}.woff') format('woff'),
         url('#{$file-path}.ttf') format('truetype'),
         url('#{$file-path}.svg##{$font-family}') format('svg');
  }
}


// Mixin for cross browser inline-block
// http://blog.mozilla.org/webdev/2009/02/20/cross-browser-inline-block/
// ------------------
@mixin inline-block {
  display: -moz-inline-stack;
  -moz-box-orient: vertical;
  display: inline-block;
  *display: inline;
  vertical-align: top;
  *zoom: 1;
}


// Clearfix
@mixin cf() {
  *zoom: 1;
  &:before, &:after {
    content: '';
    display: table;
  }
  &:after {
    clear: both;
  }
}



// Horizontal/Vertical/Both Alignment - Parent container needs position relative. IE9+
@mixin align($direction:both) {
    position: absolute;
    transform-style: preserve-3d;
    @if ($direction==horizontal) or ($direction==h) {
        left: 50%;
        transform: translateX(-50%);
    }
    @else if ($direction==vertical) or ($direction==v) {
        top: 50%;
        transform: translateY(-50%);
    }
    @else {
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
    }
}



@mixin line-clamp($numLines:1, $lineHeight:1.412) {
    overflow: hidden;
    text-overflow: -o-ellipsis-lastline;
    text-overflow: ellipsis;
    display: block;
    display: -webkit-box;
    box-orient: vertical;
    -webkit-box-orient: vertical;
    -webkit-line-clamp: $numLines;
    max-height: ($numLines * $lineHeight)+unquote("em");
}





//
// DRAW
//

// circles

@mixin circle($size: 0) {
  border-radius: 50%;
  height: auto;
  padding-bottom: 0% + $size;
  width: 0% + $size;
}

// square

@mixin square($size: 0) {
  height: auto;
  padding-bottom: 0% + $size;
  width: 0% + $size;
}

// rectangle

@mixin rectangle($size: 0) {
  height: 0;
  padding-bottom: 0% + $size / 3 *2;
  width: 0% + $size;
}


// arrow

@mixin arrow($direction, $color, $size) {
  $px-size: $size + px;
  $rem-size: ($size / 10) + rem;

  width: 0;
  height: 0;

  @if $direction == "left"{
    border-top: $px-size solid transparent;
    border-right: $px-size solid $color;
    border-bottom: $px-size solid transparent;

    border-top: $rem-size solid transparent;
    border-right: $rem-size solid $color;
    border-bottom: $rem-size solid transparent;
  }@else if $direction == "right"{
    border-top: $px-size solid transparent;
    border-bottom: $px-size solid transparent;
    border-left: $px-size solid $color;

    border-top: $rem-size solid transparent;
    border-bottom: $rem-size solid transparent;
    border-left: $rem-size solid $color;
  }@else if $direction == "up"{
    border-left: $px-size solid transparent;
    border-right: $px-size solid transparent;
    border-bottom: $px-size solid $color;

    border-left: $rem-size solid transparent;
    border-right: $rem-size solid transparent;
    border-bottom: $rem-size solid $color;
  }@else if $direction == "down"{
    border-left: $px-size solid transparent;
    border-right: $px-size solid transparent;
    border-top: $px-size solid $color;

    border-left: $rem-size solid transparent;
    border-right: $rem-size solid transparent;
    border-top: $rem-size solid $color;
  }
}
